window = "flattop" #TODO
spectrogram_options = {
    "fs": ds.fs,
    #"window": scipy.signal.windows.gaussian(len(ds.fast_time),20),
    "window": window,
    "nperseg": len(ds.fast_time),
    "noverlap": 0, #TODO
    "mode": "psd",
    "scaling": "density",
    "return_onesided": True
}
f, t, Sxx_test = scipy.signal.spectrogram(ds["data"].to_numpy().flatten(), **spectrogram_options)

#iterate through each power density at each frequency

# our outer loop is in slow time
# there are slow time number of chirps
# for each chirp, we have the power density across a range of frequencies
# for each chirp, we find the maximum power density, and then the index
# at which this occurs
# we then find the corresponding frequency index
# when then use the bandstop
bandstop1 = scipy.signal.butter(4, (10e6,18e6), btype='bandstop', output='sos', fs=ds.fs)
bandstop2 = scipy.signal.butter(4, (16e6,18e6), btype='bandstop', output='sos', fs=ds.fs)

chirp_data = 10*np.log10(np.abs(Sxx_test))

# apply simple lowpass filter to data
#print(len(amplitudes))
final_trace = np.zeros_like(data_out)
for idx, t in enumerate(ds["slow_time"]):
    trace_unfiltered = ds["data"][idx,:]
    trace_last = trace_unfiltered

    # filter out left eye
    if idx > 510 and idx < 800:
        trace_filtered = scipy.signal.sosfilt(bandstop1, trace_unfiltered)
        pulse_compressed = pulse_compress_one_trace(trace_filtered, ref_chirp_time_domain=ref_chirp)
        data_out[idx, :] = (20*np.log10(np.abs(pulse_compressed)))
        trace_last = trace_filtered

    # filter out right eye
    if idx > 1700 and idx < 1990:
        trace_filtered = scipy.signal.sosfilt(bandstop1, trace_last)
        pulse_compressed = pulse_compress_one_trace(trace_filtered, ref_chirp_time_domain=ref_chirp)
        data_out[idx, :] = (20*np.log10(np.abs(pulse_compressed)))
        trace_last = trace_filtered

    # filter out additional noise
    
    # convert signal amplitude data into np array
    amplitudes = np.array(trace_unfiltered)

    # access chirp powers
    top_val = 0
    top_val_freq_idx = 0
    for i in range(len(chirp_data)):
        if chirp_data[i][idx] > top_val:
            top_val = chirp_data[i][idx]
            top_val_freq_idx = i
            
    # access value at same index in the frequencies
    freq_mpd = f[top_val_freq_idx]
    
    # create bounds for the bandstop filter
    bandwidth = 1.56e6 #adjust bandwidth as needed
    lower_bound = freq_mpd - bandwidth
    upper_bound = freq_mpd + 1.55 * bandwidth
    if idx < 500 or idx > 2150:
        lower_bound = lower_bound - .5e6
    else:
        upper_bound = upper_bound + .3e6

    #print('lower bound: ' + str(lower_bound) + ', upper bound: ' + str(upper_bound))

    # apply bandstop filter
    filter = scipy.signal.butter(4, (lower_bound,upper_bound), btype='bandstop', output='sos', fs=ds.fs)
    trace_filtered = scipy.signal.sosfilt(filter, trace_last)

    final_trace[idx, :] = trace_filtered # for spectrogram
    pulse_compressed = pulse_compress_one_trace(trace_filtered, ref_chirp_time_domain=ref_chirp)
    data_out[idx, :] = (20*np.log10(np.abs(pulse_compressed)))
    
plot_radargram(data_out, title="Dynamic Bandstop Filtered Radargram")

snr_lowpass, snr_avg_lowpass = estimate_snr(data_out, ds["bed_pick"])
snr_avg_lowpass = 10*np.log10(snr_avg_lowpass)
print('Bandstop Filtered Average SNR = %.2f dB' % snr_avg_lowpass)
